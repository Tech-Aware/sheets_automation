function handleAchats(e) {
  const sh = e.source.getActiveSheet();
  const ss = e.source;
  const col = e.range.getColumn();
  const row = e.range.getRow();
  const turnedOn = (e.value === "TRUE") || (e.value === true);
  const turnedOff = (e.value === "FALSE") || (e.value === false);

  const STOCK_HEADER_ROW = getSheetHeaderRow_('Stock');
  const STOCK_DATA_START_ROW = getSheetDataStartRow_('Stock');

  const achatsHeaders = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
  const resolver = makeHeaderResolver_(achatsHeaders);
  const colWhere = resolver.colWhere.bind(resolver);
  const colExact = resolver.colExact.bind(resolver);

  const COL_ID   = colExact(HEADERS.ACHATS.ID);
  const COL_ART  = colExact(HEADERS.ACHATS.ARTICLE)
    || colExact(HEADERS.ACHATS.ARTICLE_ALT)
    || colWhere(h => h.includes('article'));
  const COL_MAR  = colExact(HEADERS.ACHATS.MARQUE) || colWhere(h => h.includes('marque'));
  const COL_GEN_DATA = colExact(HEADERS.ACHATS.GENRE_DATA)
    || colExact(HEADERS.ACHATS.GENRE_DATA_ALT)
    || colWhere(h => h.includes('genre') && h.includes('data'));
  const COL_GEN_LEGACY = colExact(HEADERS.ACHATS.GENRE_LEGACY) || colWhere(h => h.includes('genre'));
  const COL_GEN  = COL_GEN_DATA || (COL_GEN_LEGACY && COL_GEN_LEGACY !== COL_GEN_DATA ? COL_GEN_LEGACY : 0);
  const COL_REF  = colExact(HEADERS.ACHATS.REFERENCE) || colWhere(h => h.includes('reference'));
  const COL_DLIV = colExact(HEADERS.ACHATS.DATE_LIVRAISON) || colWhere(h => h.includes('livraison'));
  const COL_QTY  = colExact(HEADERS.ACHATS.QUANTITE_RECUE)
    || colExact(HEADERS.ACHATS.QUANTITE_RECUE_ALT)
    || colWhere(h => h.includes('quantite') && (h.includes('recu') || h.includes('recue')));
  const legacyReadyCol = colExact(HEADERS.ACHATS.PRET_STOCK)
    || colExact(HEADERS.ACHATS.PRET_STOCK_ALT)
    || colWhere(h => h.includes('pret') && h.includes('stock'));
  const legacyStpCol = colExact(HEADERS.ACHATS.DATE_MISE_EN_STOCK)
    || colExact(HEADERS.ACHATS.DATE_MISE_EN_STOCK_ALT)
    || colWhere(h => h.includes('mis en stock'))
    || colWhere(h => h.includes('mise en stock'));
  const combinedReadyCol = resolveCombinedPretPourStockColumn_(resolver);
  const useCombinedReadyCol = !!combinedReadyCol;
  const COL_READY = useCombinedReadyCol ? combinedReadyCol : legacyReadyCol;
  const COL_STP = useCombinedReadyCol ? combinedReadyCol : legacyStpCol;
  const COL_FRAIS = colExact(HEADERS.ACHATS.FRAIS_COLISSAGE)
    || colWhere(h => h.includes('frais') && h.includes('colis'));
  const COL_PRIX_TTC = colExact(HEADERS.ACHATS.PRIX_UNITAIRE_TTC)
    || colWhere(h => h.includes('prix') && h.includes('ttc') && h.includes('unit'));
  const COL_TOTAL_TTC = colExact(HEADERS.ACHATS.TOTAL_TTC)
    || colWhere(h => h.includes('total') && h.includes('ttc'));
  const isCombinedReadyCell = useCombinedReadyCol && COL_READY && COL_STP && COL_READY === COL_STP;

  function buildCheckboxRule_() {
    return SpreadsheetApp
      .newDataValidation()
      .requireCheckbox()
      .setAllowInvalid(false)
      .build();
  }

  function isCheckboxValidation_(validation) {
    return !!(validation
      && typeof validation.getCriteriaType === 'function'
      && validation.getCriteriaType() === SpreadsheetApp.DataValidationCriteria.CHECKBOX);
  }

  function restoreCheckboxValidation_(range, previousValidation) {
    if (!range) return;
    if (previousValidation && isCheckboxValidation_(previousValidation)) {
      range.setDataValidation(previousValidation);
    } else {
      range.setDataValidation(buildCheckboxRule_());
    }
    const current = range.getValue();
    if (current === '' || current === null) {
      range.setValue(false);
    }
  }

  function revertCheckbox_(range, oldValue) {
    if (!range) return;
    let valueToSet = oldValue;
    if (oldValue === 'TRUE') valueToSet = true;
    if (oldValue === 'FALSE' || oldValue === undefined) valueToSet = false;
    if (valueToSet === null || valueToSet === '') {
      range.clearContent();
      return;
    }
    range.setValue(valueToSet);
  }

  function syncReadyDateToStock_() {
    if (!COL_STP || !COL_REF) return;
    const refBase = normalizeSkuBase_(sh.getRange(row, COL_REF).getDisplayValue() || '');
    if (!refBase) return;

    const cell = sh.getRange(row, COL_STP);
    const rawVal = cell.getValue();
    let dms = null;

    if (rawVal instanceof Date && !isNaN(rawVal)) {
      dms = rawVal;
    } else {
      const s = cell.getDisplayValue();
      if (s) {
        const m = s.match(/^\s*(\d{1,2})[\/.\-](\d{1,2})[\/.\-](\d{2,4})\s*$/);
        if (m) {
          const d  = +m[1];
          const mo = +m[2];
          const y  = +(m[3].length === 2 ? ('20' + m[3]) : m[3]);
          dms = new Date(y, mo - 1, d);
        }
      }
    }

    const stock = ss.getSheetByName('Stock');
    if (!stock) return;

    const headersS = getSheetHeaders_(stock, 'Stock');
    const resolverS = makeHeaderResolver_(headersS);
    const C_SKU_STOCK = resolverS.colExact(HEADERS.STOCK.SKU)
      || resolverS.colExact(HEADERS.STOCK.REFERENCE);
    const C_DMS_STOCK = resolverS.colExact(HEADERS.STOCK.DATE_MISE_EN_STOCK);
    if (!C_SKU_STOCK || !C_DMS_STOCK) return;

    const lastS = stock.getLastRow();
    if (lastS < STOCK_DATA_START_ROW) return;

    const skuVals = stock.getRange(STOCK_DATA_START_ROW, C_SKU_STOCK, lastS - STOCK_DATA_START_ROW + 1, 1).getValues();
    const dmsVals = stock.getRange(STOCK_DATA_START_ROW, C_DMS_STOCK, lastS - STOCK_DATA_START_ROW + 1, 1).getValues();

    for (let i = 0; i < skuVals.length; i++) {
      const base = extractSkuBase_(skuVals[i][0]);
      if (!base) continue;
      if (base === refBase) {
        dmsVals[i][0] = dms;
      }
    }

    stock.getRange(STOCK_DATA_START_ROW, C_DMS_STOCK, lastS - STOCK_DATA_START_ROW + 1, 1).setValues(dmsVals);
    logDebug_('syncReadyDateToStock_', {
      refBase,
      dateMiseStock: dms,
      lignesMaj: dmsVals.length
    });
  }

  // -------------------------
  // 0) MODIF REFERENCE (F) → MAJ PRÉFIXE DES SKU DANS STOCK
  // -------------------------
  if (COL_REF && col === COL_REF) {
    const oldBase = normalizeSkuBase_(e.oldValue || "");
    const newBase = normalizeSkuBase_(e.value     || "");

    // Si pas d’ancienne valeur ou pas de nouvelle, ou identiques → rien
    if (!oldBase || !newBase || oldBase === newBase) return;

    const stock = ss.getSheetByName("Stock");
    if (!stock) return;

    const headersS = getSheetHeaders_(stock, 'Stock');
    const resolverS = makeHeaderResolver_(headersS);
    const C_SKU_STOCK = resolverS.colExact(HEADERS.STOCK.SKU)
      || resolverS.colExact(HEADERS.STOCK.REFERENCE);
    if (!C_SKU_STOCK) return;

    const lastS = stock.getLastRow();
    if (lastS < STOCK_DATA_START_ROW) return;

    const skuVals = stock.getRange(STOCK_DATA_START_ROW, C_SKU_STOCK, lastS - STOCK_DATA_START_ROW + 1, 1).getValues();
    const newSkuVals = [];

    const prefixOld = oldBase + '-';
    const prefixNew = newBase + '-';

    for (let i = 0; i < skuVals.length; i++) {
      let s = String(skuVals[i][0] || "").trim();
      if (!s) {
        newSkuVals.push([s]);
        continue;
      }

      // Cas standard: oldBase-numero → newBase-numero
      if (s.indexOf(prefixOld) === 0) {
        const suffix = s.substring(prefixOld.length); // garde le -numéro
        s = prefixNew + suffix;
        newSkuVals.push([s]);
        continue;
      }

      // Cas rare: SKU == oldBase seul
      if (s === oldBase) {
        newSkuVals.push([newBase]);
        continue;
      }

      // Autres cas → inchangé
      newSkuVals.push([s]);
    }

    stock.getRange(STOCK_DATA_START_ROW, C_SKU_STOCK, lastS - STOCK_DATA_START_ROW + 1, 1).setValues(newSkuVals);
    // On ne touche pas aux numéros, juste le préfixe.
    return;
  }

  // -------------------------
  // 1) ÉDITION DE LA COLONNE V (DATE DE MISE EN STOCK) → SYNC VERS STOCK
  // -------------------------
  if (COL_STP && col === COL_STP && !(isCombinedReadyCell && (turnedOn || turnedOff))) {
    syncReadyDateToStock_();
    return;
  }

  if (isCombinedReadyCell && COL_READY && col === COL_READY) {
    const cell = sh.getRange(row, COL_READY);
    const previousValidation = typeof cell.getDataValidation === 'function' ? cell.getDataValidation() : null;
    const wasCheckbox = isCheckboxValidation_(previousValidation);
    const oldValue = e.oldValue;
    const oldValueDate = getDateOrNull_(oldValue);
    const value = cell.getValue();
    const displayValue = cell.getDisplayValue();
    const parsedValue = getDateOrNull_(value) || getDateOrNull_(displayValue);
    let shouldSync = false;

    if (turnedOn) {
      if (wasCheckbox && typeof cell.clearDataValidations === 'function') {
        cell.clearDataValidations();
      }

      const stamp = new Date();

      cell.setValue(stamp);
      cell.setNumberFormat('dd/MM/yyyy');
      shouldSync = true;
    } else if (turnedOff) {
      restoreCheckboxValidation_(cell, previousValidation);
      cell.setValue(false);
      shouldSync = true;
    } else if (value === '' || value === null) {
      restoreCheckboxValidation_(cell, previousValidation);
      cell.clearContent();
      shouldSync = true;
    } else if (parsedValue) {
      if (wasCheckbox && typeof cell.clearDataValidations === 'function') {
        cell.clearDataValidations();
      }
      cell.setValue(parsedValue);
      cell.setNumberFormat('dd/MM/yyyy');
      shouldSync = true;
    } else {
      if (oldValueDate) {
        if (wasCheckbox && typeof cell.clearDataValidations === 'function') {
          cell.clearDataValidations();
        }
        cell.setValue(oldValueDate);
        cell.setNumberFormat('dd/MM/yyyy');
      } else {
        restoreCheckboxValidation_(cell, previousValidation);
        revertCheckbox_(cell, oldValue);
      }
      return;
    }

    if (shouldSync) {
      syncReadyDateToStock_();
    }

    if (!turnedOn) {
      return;
    }
  }

  if (COL_FRAIS && col === COL_FRAIS && COL_TOTAL_TTC) {
    const fraisCell = sh.getRange(row, COL_FRAIS);
    let frais = toNumber_(fraisCell.getValue());
    if (!Number.isFinite(frais)) {
      frais = 0;
    }

    let baseTotal = NaN;
    if (COL_QTY && COL_PRIX_TTC) {
      const qtyVal = toNumber_(sh.getRange(row, COL_QTY).getValue());
      const priceVal = toNumber_(sh.getRange(row, COL_PRIX_TTC).getValue());
      if (Number.isFinite(qtyVal) && Number.isFinite(priceVal)) {
        baseTotal = qtyVal * priceVal;
      }
    }

    const totalCell = sh.getRange(row, COL_TOTAL_TTC);
    if (!Number.isFinite(baseTotal)) {
      const currentTotal = toNumber_(totalCell.getValue());
      if (Number.isFinite(currentTotal)) {
        const previousFrais = toNumber_(e.oldValue);
        baseTotal = Number.isFinite(previousFrais) ? currentTotal - previousFrais : currentTotal;
      }
    }

    if (!Number.isFinite(baseTotal)) {
      return;
    }

    const newTotal = baseTotal + frais;
    if (!Number.isFinite(newTotal)) {
      return;
    }

    totalCell.setValue(newTotal);
    return;
  }

  // -------------------------
  // 2) CASE V "PRÊT POUR MISE EN STOCK" → CREATION LIGNES DANS STOCK
  // -------------------------
  if (!COL_READY || col !== COL_READY) return; // pas V → on sort

  if (!turnedOn) return;

  if (!COL_STP) return;
  const stpCell = sh.getRange(row, COL_STP);
  const stockStampDisplay = stpCell.getDisplayValue();
  const stockStampRaw = stpCell.getValue();

  const achatId = COL_ID ? sh.getRange(row, COL_ID).getValue() : "";
  const article = COL_ART ? String(sh.getRange(row, COL_ART).getDisplayValue() || "").trim() : "";
  const marque  = COL_MAR ? String(sh.getRange(row, COL_MAR).getDisplayValue() || "").trim() : "";
  const genrePrimary = COL_GEN_DATA
    ? String(sh.getRange(row, COL_GEN_DATA).getDisplayValue() || "").trim()
    : "";
  const fallbackGenreCol = (!genrePrimary && COL_GEN_LEGACY && COL_GEN_LEGACY !== COL_GEN_DATA)
    ? COL_GEN_LEGACY
    : 0;
  const genreFallback = fallbackGenreCol
    ? String(sh.getRange(row, fallbackGenreCol).getDisplayValue() || "").trim()
    : "";
  const genre   = genrePrimary || genreFallback;
  if (!COL_REF || !COL_QTY) return;
  const skuBase = normalizeSkuBase_(sh.getRange(row, COL_REF).getDisplayValue() || '');
  const qty     = Number(sh.getRange(row, COL_QTY).getValue());
  if (!skuBase || !Number.isFinite(qty) || qty <= 0) return;

  // Date de livraison robuste
  if (!COL_DLIV) return;
  const raw = sh.getRange(row, COL_DLIV).getValue();
  let dateLiv;
  if (raw instanceof Date && !isNaN(raw)) {
    dateLiv = raw;
  } else {
    const s = sh.getRange(row, COL_DLIV).getDisplayValue();
    const m = s && s.match(/^\s*(\d{1,2})[\/.\-](\d{1,2})[\/.\-](\d{2,4})\s*$/);
    if (!m) return;
    const d = +m[1], mo = +m[2], y = +(m[3].length === 2 ? ("20"+m[3]) : m[3]);
    dateLiv = new Date(y, mo - 1, d);
  }

  const target = ss.getSheetByName("Stock");
  if (!target) return;

  // Repère dynamiquement les colonnes de Stock
  const headersStock = target.getRange(1, 1, 1, Math.max(4, target.getLastColumn())).getValues()[0];
  const resolverStock = makeHeaderResolver_(headersStock);

  const COL_ID_STOCK    = resolverStock.colExact(HEADERS.STOCK.ID);
  const COL_LABEL_STOCK = resolverStock.colWhere(h => h.includes('libell')) || resolverStock.colWhere(h => h.includes('article')) || 2;
  const COL_OLD_STOCK   = resolverStock.colExact(HEADERS.STOCK.OLD_SKU);
  const COL_SKU_STOCK   = resolverStock.colExact(HEADERS.STOCK.SKU)
    || resolverStock.colExact(HEADERS.STOCK.REFERENCE)
    || resolverStock.colWhere(h => h.includes('sku'))
    || 3;
  const COL_DATE_STOCK  = resolverStock.colWhere(h => h.includes('livraison')) || (COL_SKU_STOCK ? COL_SKU_STOCK + 1 : 0);
  const C_DMS_STOCK     = resolverStock.colExact(HEADERS.STOCK.DATE_MISE_EN_STOCK); // optionnel

  const base = skuBase;
  const label = `${article} ${marque} ${genre}`.trim();

  const lastExistingStockRow = target.getLastRow();
  let existingStockHasBase = false;
  let existingStockDms = null;
  if (lastExistingStockRow >= 2 && COL_SKU_STOCK) {
    const existingSkuValues = target.getRange(2, COL_SKU_STOCK, lastExistingStockRow - 1, 1).getValues();
    let existingDmsValues = null;
    if (C_DMS_STOCK) {
      existingDmsValues = target.getRange(2, C_DMS_STOCK, lastExistingStockRow - 1, 1).getValues();
    }
    let existingIdValues = null;
    if (COL_ID_STOCK) {
      existingIdValues = target.getRange(2, COL_ID_STOCK, lastExistingStockRow - 1, 1).getValues();
    }
    const prefix = `${base}-`;
    const legacyPrefix = base;
    const achatIdKey = (achatId === null || achatId === undefined || achatId === '') ? '' : String(achatId);
    for (let i = 0; i < existingSkuValues.length; i++) {
      const rawSku = normalizeSkuBase_(existingSkuValues[i][0]);
      if (!rawSku || (rawSku.indexOf(prefix) !== 0 && rawSku.indexOf(legacyPrefix) !== 0)) continue;

      let idMatches = true;
      let storedIdKey = '';
      if (COL_ID_STOCK && existingIdValues) {
        const storedRaw = existingIdValues[i] && existingIdValues[i][0];
        storedIdKey = (storedRaw === null || storedRaw === undefined || storedRaw === '') ? '' : String(storedRaw);
        if (achatIdKey && storedIdKey) {
          idMatches = (storedIdKey === achatIdKey);
        }
      }

      if (!idMatches) {
        continue;
      }

      existingStockHasBase = true;

      if (existingDmsValues && !existingStockDms && COL_ID_STOCK && achatIdKey && storedIdKey && storedIdKey === achatIdKey) {
        const candidate = existingDmsValues[i][0];
        if (candidate instanceof Date && !isNaN(candidate)) {
          existingStockDms = candidate;
        }
      }
    }
  }

  if (existingStockHasBase) {
    if (COL_STP && !getDateOrNull_(stockStampRaw)) {
      const fallbackDms = existingStockDms || getDateOrNull_(stockStampDisplay);
      if (fallbackDms) {
        stpCell.setValue(fallbackDms);
      }
    }
    renumberStockByBrand_();
    return;
  }

  // Date de mise en stock : on fixe maintenant ET on la garde dans Achats!V
  let miseStockDate = getDateOrNull_(stockStampRaw);
  if (!miseStockDate) {
    miseStockDate = getDateOrNull_(stockStampDisplay);
  }
  if (!miseStockDate) {
    miseStockDate = new Date();
  }
  if (!(stockStampRaw instanceof Date) || isNaN(stockStampRaw)) {
    stpCell.setValue(miseStockDate);
  }

  const width = Math.max(target.getLastColumn(), COL_LABEL_STOCK || 0, COL_SKU_STOCK || 0, COL_DATE_STOCK || 0, COL_ID_STOCK || 0, COL_OLD_STOCK || 0);
  const rows = Array.from({length: qty}, () => Array(Math.max(1, width)).fill(""));

  for (let i = 0; i < rows.length; i++) {
    const rowValues = rows[i];
    if (COL_ID_STOCK) rowValues[COL_ID_STOCK - 1] = achatId;
    if (COL_LABEL_STOCK) rowValues[COL_LABEL_STOCK - 1] = label;
    if (COL_OLD_STOCK) rowValues[COL_OLD_STOCK - 1] = "";
    if (COL_SKU_STOCK) rowValues[COL_SKU_STOCK - 1] = `${base}-0`;
    if (COL_DATE_STOCK) rowValues[COL_DATE_STOCK - 1] = dateLiv;
  }

  const start = Math.max(STOCK_DATA_START_ROW, target.getLastRow() + 1);
  target.getRange(start, 1, rows.length, rows[0].length).setValues(rows);

  if (C_DMS_STOCK) {
    target.getRange(start, C_DMS_STOCK, rows.length, 1).setValue(miseStockDate);
  }

  const lastS = target.getLastRow();
  if (lastS >= STOCK_DATA_START_ROW && COL_DATE_STOCK) {
    target.getRange(STOCK_DATA_START_ROW, 1, lastS - STOCK_DATA_START_ROW + 1, target.getLastColumn())
          .sort({ column: COL_DATE_STOCK, ascending: true });
    target.getRange(STOCK_DATA_START_ROW, COL_DATE_STOCK, lastS - STOCK_DATA_START_ROW + 1, 1).setNumberFormat("dd/MM/yyyy");
  }

  renumberStockByBrand_();
}

// === RE-NUMÉROTATION GLOBALE PAR BASE DE SKU AVEC OVERRIDE PAR B ===
//
// - Base = toutes les parties avant le dernier "-" du SKU actuel (col "SKU").
// - Si B (SKU ancienne) contient un nombre en fin, on utilise ce nombre pour ce produit.
// - Sinon, on numérote en continu pour cette base à partir de 1.
// - Pas de zéros en tête: suffixe = "1", "2", "3", ...
// - Paramètre onlyOld = true → on ne renumérote QUE les lignes où B est rempli.

function renumberStockByBrand_(onlyOld) {
  const ss = SpreadsheetApp.getActive();
  const stock  = ss.getSheetByName('Stock');
  if (!stock) return;

  const headerRow = getSheetHeaderRow_('Stock');
  const dataStartRow = getSheetDataStartRow_('Stock');

  const last = stock.getLastRow();
  if (last < dataStartRow) return;

  onlyOld = !!onlyOld;

  const stockHeaders = getSheetHeaders_(stock, 'Stock');
  const resolver = makeHeaderResolver_(stockHeaders);
  const COL_ID    = resolver.colExact('id');
  const COL_OLD   = resolver.colExact(HEADERS.STOCK.OLD_SKU) || resolver.colWhere(h => h.includes('ancienne')) || 2; // B
  const COL_NEW   = resolver.colExact(HEADERS.STOCK.SKU)
    || resolver.colExact(HEADERS.STOCK.REFERENCE)
    || resolver.colWhere(h => h.includes('sku'))
    || 3; // C

  const width = Math.max(COL_NEW, COL_OLD, COL_ID || 0, stock.getLastColumn());
  const data = stock.getRange(dataStartRow, 1, last - dataStartRow + 1, width).getValues();

  const idToBase = COL_ID ? buildIdToSkuBaseMap_(ss) : null;
  const baseCounters = Object.create(null);
  const rowInfos = [];

  for (let i = 0; i < data.length; i++) {
    const row = data[i];

    const oldSku = String(row[COL_OLD - 1] || "").trim();  // SKU ancienne
    const curSku = String(row[COL_NEW - 1] || "").trim();   // SKU actuelle (base-0 ou autre)
    const idRaw = (COL_ID ? row[COL_ID - 1] : '');
    const idKey = idRaw === null || idRaw === undefined || idRaw === '' ? '' : String(idRaw);

    const idBase = (idKey && idToBase && idToBase[idKey]) ? idToBase[idKey] : '';
    const curBase = extractSkuBase_(curSku);
    const oldBase = extractSkuBase_(oldSku);

    let base = curBase || oldBase || idBase;
    if (base && idBase && base !== idBase) {
      const curAligned = !curBase || curBase === idBase;
      const oldAligned = !oldBase || oldBase === idBase;
      if (curAligned && oldAligned) {
        base = idBase;
      }
    }

    let overrideSuffix = null;
    let curSuffix = null;

    if (base) {
      const counterKey = base;
      if (!Object.prototype.hasOwnProperty.call(baseCounters, counterKey)) {
        baseCounters[counterKey] = 0;
      }

      if (oldSku && (!oldBase || oldBase === base)) {
        overrideSuffix = extractSkuSuffix_(oldSku, base);
        if (overrideSuffix != null) {
          baseCounters[counterKey] = Math.max(baseCounters[counterKey], overrideSuffix);
        }
      }

      if (curSku && (!curBase || curBase === base)) {
        curSuffix = extractSkuSuffix_(curSku, base);
        if (curSuffix != null) {
          baseCounters[counterKey] = Math.max(baseCounters[counterKey], curSuffix);
        }
      }
    }

    rowInfos.push({
      base,
      oldSku,
      curSku,
      overrideSuffix,
      curSuffix
    });
  }

  const newSkuColValues = [];

  for (let i = 0; i < rowInfos.length; i++) {
    const info = rowInfos[i];
    const base = info.base;
    const oldSku = info.oldSku;
    const curSku = info.curSku;

    if (onlyOld && !oldSku) {
      newSkuColValues.push([curSku]);
      continue;
    }

    if (!base) {
      newSkuColValues.push([curSku]);
      continue;
    }

    const counterKey = base;
    if (!Object.prototype.hasOwnProperty.call(baseCounters, counterKey)) {
      baseCounters[counterKey] = 0;
    }

    if (info.overrideSuffix != null) {
      baseCounters[counterKey] = Math.max(baseCounters[counterKey], info.overrideSuffix);
      newSkuColValues.push([counterKey + '-' + info.overrideSuffix]);
      continue;
    }

    if (info.curSuffix != null) {
      baseCounters[counterKey] = Math.max(baseCounters[counterKey], info.curSuffix);
      newSkuColValues.push([curSku]);
      continue;
    }

    const nextSuffix = baseCounters[counterKey] + 1;
    baseCounters[counterKey] = nextSuffix;
    newSkuColValues.push([counterKey + '-' + nextSuffix]);
  }

  stock.getRange(dataStartRow, COL_NEW, newSkuColValues.length, 1).setValues(newSkuColValues);
}